class MedianMaintainingHeap:
    def __init__(self):
        self.hmin = MinHeap()
        self.hmax = MaxHeap()
    def satisfies_assertions(self):
        if self.hmin.size() ==0:
            assert self.hmax.size()==0
            return
        if self.hmax.size() ==0:
            assert self.hmin.size()==1
            return
        ## min heap min element >= max heap max element
        assert self.hmax.max_element() <= self.hmin.min_element(), f'Failed: Max element of max heap is larter than min element of min heap'
        ## size of max heap must be equal or one less than min heap
        s_min = self.hmin.size()
        s_max = self.hmax.size()
        assert (s_min == s_max or s_max == s_min -1), f'Heap sizes are not balanced'
    
    def __repr__(self):
        return 'Maxheap:' + str(self.hmax) + 'Minheap:' + str(self.hmin)
    def get_median(self):
        if self.hmin.size()==0:
            assert self.hmax.size()==0, f'Sizes are not balanced'
            assert False, 'Cannot ask for median from empty heaps'
        if self.hmax.size()==0:
            assert self.hmin.size()==1, f'sizes are not balanced'
            return self.hmin.min_element()
        #get median
        if self.hmin.size() == self.hmax.size():
            return (self.hmin.min_element() + self.hmax.max_element())/2
        elif self.hmin.size() - self.hmax.size() ==1:
            return self.hmin.min_element()
        else:
            assert False, f'size are not balanced'
    ## function: balanced heap sizes
    def balance_heap_sizes(self):
        if self.hmax.size()==self.hmin.size() or self.hmax.size() +1 == self.hmin.size():
            return
        elif self.hmax.size()>self.hmin.size():
            self.hmin.insert(self.hmax.max_element())
            self.hmax.delete_max()
            self.balance_heap_sizes()
        else:
            self.hmax.insert(self.hmin.min_element())
            self.hmin.delete_min()
            self.balance_heap_sizes()
    def insert(self,elt):
        if self.hmin.size()==0:
            # min heap is empty -- directly insert into min heap
            self.hmin.insert(elt)
            return
        if self.hmax.size()==0:
            # max heap is empty -- this better happen only if min heap has size 1,
            assert self.hmin.size() ==1
            if elt>self.hmin.min_element():
                # element needs to go into the min heap
                current_min = self.hmin.min_element()
                self.hmin.delete_min()
                self.hmin.insert(elt)
                self.hmax.insert(current_min)
            else:
                # element goes into the max heap -- directly insert it
                self.hmax.insert(elt)
            return
        # assume both heaps are non-empty
        # if element is smaller than max element in max heap, element goes into max heap
        if elt<=self.hmax.max_element():
            self.hmax.insert(elt)
            self.balance_heap_sizes()
        # otherwise, element goes into min heap
        else:
            self.hmin.insert(elt)
            self.balance_heap_sizes()
    def delete_median(self):
        self.hmax.delete_max()
        self.balance_heap_sizes()
                
